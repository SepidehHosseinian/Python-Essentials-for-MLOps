# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

"""Contains functionality for managing submitted training runs in Azure Machine Learning."""

from __future__ import print_function
import os
import json
import logging

from azureml._html.utilities import to_formatted_html_table
from azureml._common._error_definition import AzureMLError
from azureml._common._core_user_error.user_error import InvalidUri, InvalidStatus
from azureml.core.run import Run
from azureml.core.runconfig import RunConfiguration
from azureml.exceptions import AzureMLException, UserErrorException

module_logger = logging.getLogger(__name__)


class ScriptRun(Run):
    """Provides programmatic access for managing submitted training runs.

    A run submitted with :class:`azureml.core.script_run_config.ScriptRunConfig` represents a single trial in
    an experiment. Submitting the run returns a ScriptRun object, which can be used to monitor the asynchronous
    execution of the run, log metrics and store output of the run, and analyze results and access artifacts
    generated by the run.

    To get started with experiments and ScriptRunConf, see

    * `Create and manage environments for training and
      deployment <https://docs.microsoft.com/azure/machine-learning/how-to-use-environments>`_
    * `How to manage runs <https://docs.microsoft.com/azure/machine-learning/how-to-manage-runs>`_

    .. remarks::

        The Azure Machine Learning SDK provides you with a series of interconnected classes, that are
        designed to help you train and compare machine learning models that are related by the shared
        problem that they are solving.

        An :class:`azureml.core.Experiment` acts as a logical container for these training runs. A
        :class:`azureml.core.RunConfiguration` object is used to codify the information necessary to
        submit a training run in an experiment. A :class:`azureml.core.ScriptRunConfig` object is a
        helper class that packages the RunConfiguration object with an execution script for training;
        see the python code example in the documentation for :class:`azureml.core.RunConfiguration`
        for an example of a ScriptRunConfig object in action.

        A ScriptRunConfig object is used to submit a training run as part of an Experiment.
        When a training run is submitted using a ScriptRunConfig object, the submit method returns an
        object of type ScriptRun.

        A ScriptRun object gives you programmatic access to information about the associated training
        run. Some examples include retrieving the logs corresponding to a run, canceling a run if it's
        still in progress, cleaning up the artifacts of a completed run, and waiting for completion of
        a run currently in progress.

    :param experiment: The experiment object.
    :type experiment: azureml.core.experiment.Experiment
    :param run_id: The run ID.
    :type run_id: str
    :param directory: The source directory.
    :type directory: str
    :param _run_config: A run configuration.
    :type _run_config: azureml.core.runconfig.RunConfiguration
    :param kwargs: A dictionary of additional configuration parameters.
    :type kwargs: dict
    """

    RUN_TYPE = "azureml.scriptrun"

    def __init__(self, experiment, run_id, directory=None, _run_config=None, **kwargs):
        """Class ScriptRun constructor."""
        from azureml._project.project import Project
        super(ScriptRun, self).__init__(experiment, run_id, **kwargs)
        project_object = Project(experiment=experiment, directory=directory, _disable_service_check=True)
        if _run_config is not None:
            self._run_config_object = RunConfiguration._get_run_config_object(directory, _run_config)
        else:
            self._run_config_object = None
        self._project_object = project_object
        self._output_logs_pattern = r"(user_logs/std_log[\D]*[0]*(?:_ps)?\.txt)|(azureml-logs/[\d]{2}.+\.txt)"

    @property
    def _run_config(self):
        if self._run_config_object is None:
            # Get it from experiment in the cloud.
            run_details = self.get_details()
            self._run_config_object = RunConfiguration._get_runconfig_using_run_details(run_details)
        return self._run_config_object

    def _download_working_directory(self, destination=None):
        """
        Download the run's working directory.

        :param destination: The destination path to store the diagnostics zip. If unspecified, the zip
            will be placed in the project directory.
        :type destination: str
        """
        if destination:
            if os.path.exists(destination) and not os.path.isdir(destination):
                raise UserErrorException("{} exists and is not a directory.".format(destination))
        else:
            destination = self._project_object.project_directory

        os.makedirs(destination, exist_ok=True)
        uri = self._run_dto.get('diagnostics_uri', None)
        if uri:
            response = self._client.diagnostics(uri=uri)
            target_file = os.path.join(destination, '{}-diagnostics.zip'.format(self.id))
            with open(target_file, 'wb') as local_file:
                for chunk in response.iter_content(chunk_size=1024):
                    local_file.write(chunk)
        else:
            azureml_error = AzureMLError.create(
                InvalidUri
            )
            raise AzureMLException._with_error(azureml_error)

    def cancel(self):
        """Cancel the ongoing run."""
        target = self._run_config.target
        if target == "local":
            self._cancel_local()
        else:
            super(ScriptRun, self).cancel()

    def _cancel_local(self):
        project_temp_dir = _get_project_temporary_directory(self._run_id)

        # Check if compute target is current machine
        if os.path.exists(project_temp_dir):
            from azureml._base_sdk_common.common import normalize_windows_paths
            killfile = normalize_windows_paths(os.path.join(project_temp_dir, "azureml-setup", "killfile"))
            if not os.path.exists(killfile):
                with open(killfile, 'w+') as f:
                    f.write(self._run_id)
        else:
            module_logger.warning(
                "The run is not running on the current machine, "
                + "so the run processes may not be terminated. The run status will be marked as \"Cancelled\".")

        self._client.run.post_event_canceled()

    def _get_process_status(self, status_list=None):
        """
        Display the process information and status of all the run's processes.

        This is done by parsing two files: process_info and process_status.
            An example entry from process_info:
            {"process_name":"worker_1",
            "node_id":"tvmps_c4f49c5256bf6a6f11aba787a7ad15e29468725d9ee93a37002d6bbc07f15e4b_d",
            "pid_in_container":183,
            "private_ip":"10.0.0.5",
            "log":"azureml-logs/70_driver_log_1.txt"}

            An example entry from process_status:
            {"process_name":"worker_1",
            "timestamp":"2019-10-28T22:30:10.764428389Z",
            "status":"Started"}
        :param status_list: A list of statuses. If set, only the processes with a status in status_list
        will be displayed. Valid statuses are: 'Started', 'Terminated', 'Failed', 'Completed'.
        :type status_list: list
        """
        # Parse both status and info files
        try:
            process_info, process_status = self._parse_process_files()
        except KeyError:
            azureml_error = AzureMLError.create(
                InvalidStatus
            )
            raise AzureMLException._with_error(azureml_error)

        # Store latest status information in a dictionary since process_status
        # is updated multiple times for each process
        status_dict = {}
        for status_entry in process_status:
            if status_entry['process_name'] not in status_dict.keys():
                status_dict[status_entry['process_name']] = {}
            if status_entry['status'] == 'Started':
                status_dict[status_entry['process_name']]['Start Time'] = status_entry['timestamp']
            else:
                status_dict[status_entry['process_name']]['End Time'] = status_entry['timestamp']

            status_dict[status_entry['process_name']]['Status'] = status_entry['status']

        # A line with 'process_name' * is appended to the end of the process_status file at the end of
        # each run. This indicates that some process might have been terminated in case of failure.
        if process_status[-1]['process_name'] == '*':
            for process_name in status_dict.keys():
                if status_dict[process_name]['Status'] not in _ProcessStatus.TERMINATING_STATUSES:
                    status_dict[process_name]['Status'] = 'Terminated'
                    status_dict[process_name]['End Time'] = process_status[-1]['timestamp']

        table = []

        # Add the status information to the process information
        for line in process_info:
            row = [value for value in line.values()]
            # Filter first
            if not status_list or status_dict.get(line['process_name']).get('Status', 'N/A') in status_list:
                row.insert(1, status_dict.get(line['process_name']).get('Status', 'N/A'))
                row.insert(2, status_dict.get(line['process_name']).get('Start Time', 'N/A'))
                row.insert(3, status_dict.get(line['process_name']).get('End Time', 'N/A'))
                table.append(row)

        # Sort on IP address
        process_status = _ProcessStatus(table)
        process_status._sort('Private IP')
        return process_status

    def _parse_process_files(self):
        details = self.get_details_with_logs()
        log_files = details["logFiles"]
        process_info_file = log_files[self.get_properties()['ProcessInfoFile']]
        process_status_file = log_files[self.get_properties()['ProcessStatusFile']]
        info = [json.loads(line) for line in process_info_file.splitlines()]
        status = [json.loads(line) for line in process_status_file.splitlines()]
        return info, status

    @staticmethod
    def _from_run_dto(experiment, run_dto, **kwargs):
        """Return run from dto.

        :param experiment:
        :type experiment: azureml.core.experiment.Experiment
        :param run_dto:
        :type run_dto: object
        :return: Returns the run
        :rtype: ScriptRun
        """
        return ScriptRun(experiment, run_dto.run_id, _run_dto=run_dto, **kwargs)


def _get_project_temporary_directory(run_id):
    import tempfile
    azureml_temp_dir = os.path.join(tempfile.gettempdir(), "azureml_runs")
    if not os.path.isdir(azureml_temp_dir):
        os.mkdir(azureml_temp_dir)

    project_temp_dir = os.path.join(azureml_temp_dir, run_id)
    return project_temp_dir


class _ProcessStatus(object):
    TERMINATING_STATUSES = ['Failed', 'Completed', 'Terminated']

    def __init__(self, rows):
        self.rows = rows
        self.header = ['Process', 'Status', 'Start Time', 'End Time', 'Node ID',
                       'PID in Container', 'Private IP', 'Log']

    def _sort(self, column):
        if column in self.header:
            self.rows.sort(key=lambda x: x[self.header.index(column)])

    def _repr_html_(self):
        return to_formatted_html_table(self.rows, header=self.header)

    def __str__(self):
        longest_cols = [(max([len(str(row[i])) for row in (self.rows + [self.header])]) + 3)
                        for i in range(len(self.header))]
        row_format = "".join(["{:>" + str(longest_col) + "}" for longest_col in longest_cols])

        result = row_format.format(*self.header)
        result += '\n'
        for row in self.rows:
            result += row_format.format(*row)
            result += '\n'

        return result
