# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator 2.3.33.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model


class AISuperComputerScalePolicy(Model):
    """Every job in Singularity is implicitly elastic and preemptible. By
    leveraging elastic training, the job will
    automatically scale up when there is extra capacity available, and
    automatically scale down when resources are gradually called back.
    Elastic training is capable of automatically scaling up or scaling down
    jobs at the Instance Type granularity
    to take advantage of available capacity (e.g., GPUs, CPUs) or scale down
    the job when fewer resources are available.

    :param auto_scale: Specifies whether the job should be elastic or not.
     When true, the scheduler tries to allocate the maximum instance type count
     (Microsoft.MachineLearning.Execution.Contracts.AISuperComputerScalePolicy.MaxInstanceTypeCount).
     If there is not enough capacity, then the job will continually scale down
     automatically.
    :type auto_scale: bool
    :param auto_scale_instance_type_count_set: The list of instance type
     counts available for elastically scaling the job.
     Assume currentInstanceTypeCount = 4 and autoScaleInstanceTypeCountSet =
     [2,4,8],
     the job will automatically scale down as 8-&gt;4-&gt;2 when less capacity
     is available,
     and scale up as 2-&gt;4-&gt;8 when more capacity is available.
    :type auto_scale_instance_type_count_set: list[int]
    :param auto_scale_interval_in_sec: The minimum interval in seconds between
     job autoscaling.
     You are recommended to set the autoScaleIntervalInSec longer than the
     checkpoint interval,
     to make sure at least one checkpoint is saved before auto-scaling of the
     job.
    :type auto_scale_interval_in_sec: int
    :param max_instance_type_count: The maximum instance type count.
    :type max_instance_type_count: int
    :param min_instance_type_count: The minimum instance type count.
    :type min_instance_type_count: int
    """

    _attribute_map = {
        'auto_scale': {'key': 'autoScale', 'type': 'bool'},
        'auto_scale_instance_type_count_set': {'key': 'autoScaleInstanceTypeCountSet', 'type': '[int]'},
        'auto_scale_interval_in_sec': {'key': 'autoScaleIntervalInSec', 'type': 'int'},
        'max_instance_type_count': {'key': 'maxInstanceTypeCount', 'type': 'int'},
        'min_instance_type_count': {'key': 'minInstanceTypeCount', 'type': 'int'},
    }

    def __init__(self, auto_scale=None, auto_scale_instance_type_count_set=None, auto_scale_interval_in_sec=None, max_instance_type_count=None, min_instance_type_count=None):
        super(AISuperComputerScalePolicy, self).__init__()
        self.auto_scale = auto_scale
        self.auto_scale_instance_type_count_set = auto_scale_instance_type_count_set
        self.auto_scale_interval_in_sec = auto_scale_interval_in_sec
        self.max_instance_type_count = max_instance_type_count
        self.min_instance_type_count = min_instance_type_count
