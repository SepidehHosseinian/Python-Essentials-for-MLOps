# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator 2.3.33.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse

from .. import models


class MLModelsOperations(object):
    """MLModelsOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config

    def query_by_id(
            self, subscription_id, resource_group, workspace, id, custom_headers=None, raw=False, **operation_config):
        """Gets a model.

        Gets a model by model id.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The model id.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Model or ClientRawResponse if raw=true
        :rtype: ~_restclient.models.Model or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.query_by_id.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    query_by_id.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models/{id}'}

    def delete(
            self, subscription_id, resource_group, workspace, id, custom_headers=None, raw=False, **operation_config):
        """Delete the specified Model.

        Deletes a model if it exists.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The model id.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.delete.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 204]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models/{id}'}

    def patch(
            self, subscription_id, resource_group, workspace, id, body, custom_headers=None, raw=False, **operation_config):
        """Patch a specific model.

        Updates an existing model with the specified patch.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param id: The model id.
        :type id: str
        :param body: The payload that is used to patch the model.
        :type body: list[~_restclient.models.JsonPatchOperation]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Model or ClientRawResponse if raw=true
        :rtype: ~_restclient.models.Model or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.patch.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str'),
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, '[JsonPatchOperation]')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    patch.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models/{id}'}

    def list_query(
            self, subscription_id, resource_group, workspace, name=None, tag=None, framework=None, description=None, count=None, offset=None, skip_token=None, tags=None, properties=None, run_id=None, dataset_id=None, order_by=None, latest_version_only=False, custom_headers=None, raw=False, **operation_config):
        """Query the list of Models in a workspace.

        The result list can be filtered using tag and name. If no filter is
        passed, the query lists all the Models in the given workspace. The
        returned list is paginated and the count of items in each page is an
        optional parameter.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param name: The object name.
        :type name: str
        :param tag: The object tag.
        :type tag: str
        :param framework: The framework.
        :type framework: str
        :param description: The object description.
        :type description: str
        :param count: The number of items to retrieve in a page.
        :type count: int
        :param offset: The (zero-based) offset of the first item in the
         collection to return continuation token to retrieve the next page.
        :type offset: int
        :param skip_token: The continuation token to retrieve the next page.
        :type skip_token: str
        :param tags: A set of tags with which to filter the returned models.
         It is a comma separated string of tags key or tags key=value
         Example: tagKey1,tagKey2,tagKey3=value3 .
        :type tags: str
        :param properties: A set of properties with which to filter the
         returned models.
         It is a comma separated string of properties key and/or properties
         key=value
         Example: propKey1,propKey2,propKey3=value3 .
        :type properties: str
        :param run_id: The runId which created the model.
        :type run_id: str
        :param dataset_id: The datasetId associated with the model.
        :type dataset_id: str
        :param order_by: An option to specify how the models are ordered in
         the response.
        :type order_by: str
        :param latest_version_only: An option to get only the latest version
         of the models in the response.
        :type latest_version_only: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PaginatedModelList or ClientRawResponse if raw=true
        :rtype: ~_restclient.models.PaginatedModelList or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.list_query.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if tag is not None:
            query_parameters['tag'] = self._serialize.query("tag", tag, 'str')
        if framework is not None:
            query_parameters['framework'] = self._serialize.query("framework", framework, 'str')
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str')
        if count is not None:
            query_parameters['count'] = self._serialize.query("count", count, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        if tags is not None:
            query_parameters['tags'] = self._serialize.query("tags", tags, 'str')
        if properties is not None:
            query_parameters['properties'] = self._serialize.query("properties", properties, 'str')
        if run_id is not None:
            query_parameters['runId'] = self._serialize.query("run_id", run_id, 'str')
        if dataset_id is not None:
            query_parameters['datasetId'] = self._serialize.query("dataset_id", dataset_id, 'str')
        if order_by is not None:
            query_parameters['orderBy'] = self._serialize.query("order_by", order_by, 'str')
        if latest_version_only is not None:
            query_parameters['latestVersionOnly'] = self._serialize.query("latest_version_only", latest_version_only, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PaginatedModelList', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_query.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models'}

    def register(
            self, subscription_id, resource_group, workspace, body, custom_headers=None, raw=False, **operation_config):
        """Register a model.

        Register the model provided.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to register the model.
        :type body: ~_restclient.models.Model
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Model or ClientRawResponse if raw=true
        :rtype: ~_restclient.models.Model or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.register.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'Model')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    register.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models'}

    def list_query_post(
            self, subscription_id, resource_group, workspace, body=None, custom_headers=None, raw=False, **operation_config):
        """Query the list of Models in a Workspace.

        If no filter is passed, the query lists all Models in the Workspace.
        The returned list is paginated and the count of item in each page is an
        optional parameter.

        :param subscription_id: The Azure Subscription ID.
        :type subscription_id: str
        :param resource_group: The Name of the resource group in which the
         workspace is located.
        :type resource_group: str
        :param workspace: The name of the workspace.
        :type workspace: str
        :param body: The payload that is used to list models.
        :type body: ~_restclient.models.ListModelsRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PaginatedModelListPost or ClientRawResponse if raw=true
        :rtype: ~_restclient.models.PaginatedModelListPost or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ModelErrorResponseException<_restclient.models.ModelErrorResponseException>`
        """
        # Construct URL
        url = self.list_query_post.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("subscription_id", subscription_id, 'str'),
            'resourceGroup': self._serialize.url("resource_group", resource_group, 'str'),
            'workspace': self._serialize.url("workspace", workspace, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'ListModelsRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ModelErrorResponseException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PaginatedModelListPost', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_query_post.metadata = {'url': '/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/models/list'}
